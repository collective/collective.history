import logging

#events
from zope.lifecycleevent.interfaces import (
    IObjectCopiedEvent,
    IObjectMovedEvent,
    IObjectRemovedEvent,
    IObjectModifiedEvent
)
from Products.Archetypes.interfaces.event import (
    IObjectEditedEvent,
    IObjectInitializedEvent,
)
#from Products.CMFCore.interfaces._events import IActionSucceededEvent
from Products.DCWorkflow.interfaces import (
    IAfterTransitionEvent,
)

from collective.history.useraction import BaseUserActionWrapper
from collective.history.handler import BaseHandler
from Products.CMFCore.utils import getToolByName

LOG = logging.getLogger("collective.history")


class ArchetypesUserActionWrapper(BaseUserActionWrapper):
    """This is an archetypes specialized wrapper of useraction"""

    def extract_what(self):
        #Archetypes
        if IObjectInitializedEvent.providedBy(self.event):
            return 'created', self.get_object_modified_info()
        elif IObjectEditedEvent.providedBy(self.event):
            return 'edited', self.get_object_modified_info()
#        #TODO: plone.app.iterate
#        elif ICheckinEvent.providedBy(self.event):
#            return 'checkedin'
#        elif ICheckoutEvent.providedBy(self.event):
#            return 'checkedout'
#        elif IWorkingCopyDeletedEvent.providedBy(self.event):
#            return 'workingcopydeleted'
        # DCWorkflow
        elif IAfterTransitionEvent.providedBy(self.event):
            return 'statechanged', self.get_transition_info()
        # CMFCore (useless)
#        elif IActionSucceededEvent.providedBy(self.event):
#            return None
#            return 'statechanged', self.get_action_succeed_info()
        # zope
#        elif IObjectAddedEvent.providedBy(self.event):
#            return 'added', self.get_object_moved_info()
        elif IObjectCopiedEvent.providedBy(self.event):
            return 'copied', self.get_object_copied_info()
        elif IObjectMovedEvent.providedBy(self.event):
            return 'moved', self.get_object_moved_info()
        elif IObjectRemovedEvent.providedBy(self.event):
            return 'deleted', self.get_object_moved_info()
        elif IObjectModifiedEvent.providedBy(self.event):
            return 'modified', self.get_object_modified_info()
        else:
            #TODO: provide a query component to let addon register things
            pass
        return None, {}

    def is_valid_event(self):
        blacklist = (
            'OFS.interfaces.IObjectWillBeRemovedEvent',
            'OFS.interfaces.IObjectWillBeMovedEvent',
            'Products.Archetypes.interfaces.event.IEditBegunEvent',
            'Products.CMFCore.interfaces._events.IActionSucceededEvent',
            'Products.CMFCore.interfaces._events.IActionWillBeInvokedEvent',
            'Products.DCWorkflow.interfaces.IBeforeTransitionEvent',
            'zope.lifecycleevent.interfaces.IObjectCreatedEvent',
            'zope.lifecycleevent.interfaces.IObjectAddedEvent',
            #'zope.lifecycleevent.interfaces.IObjectModifiedEvent',
        )
        for iface in blacklist:
            if self.what == iface:
                return False
        # do not keep moved event from the add process
        if self.what == 'moved':
            plone_tool = getToolByName(self.event.object, 'plone_utils')
            newName = self.event.newName
            oldName = self.event.oldName
            if newName and plone_tool.isIDAutoGenerated(self.event.newName):
                return False
            if oldName and plone_tool.isIDAutoGenerated(self.event.oldName):
                return False
            #remove is moved ... kinda weird, let's fix it:
            if not newName:
                self.data["what"] = "deleted"
            if not oldName:
                return False
        # do not keep dcworkflow initialization
        if self.what == "statechanged":
            if self.event.old_state == self.event.new_state:
                return False
        validated = super(ArchetypesUserActionWrapper, self).is_valid_event()
        return validated


class HandleArchetypesUserAction(BaseHandler):
    """This handler is specialized for archetypes"""

    wrapper_class = ArchetypesUserActionWrapper
